<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Urban Safety Navigation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #map {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #three-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        #status-overlay {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            font-size: 16px;
            border-radius: 8px;
            z-index: 3;
            transition: background-color 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="map"></div>
        <canvas id="three-canvas"></canvas>
        <div id="status-overlay">Safe Zone</div>
    </div>

    <script>
        class SafetyNavigationGame {
            constructor() {
                this.startLat = 28.6139;
                this.startLng = 77.2090;
                this.initMap();
                this.addDangerZones();
                this.initThreeScene();
                this.setupControls();
            }

            initMap() {
                this.map = L.map('map').setView([this.startLat, this.startLng], 13);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(this.map);
            }

            addDangerZones() {
                this.dangerZones = [];

                const addZone = (lat, lng, radius, level, color, description) => {
                    this.dangerZones.push({ lat, lng, radius, level, color, description });
                    L.circle([lat, lng], {
                        color: color,
                        fillColor: color,
                        fillOpacity: 0.2,
                        radius: radius
                    }).addTo(this.map);
                };

                // Add danger zones
                const riskLevels = [
                    { level: 'high', color: 'red', radius: 500 },
                    { level: 'moderate', color: 'orange', radius: 300 },
                    { level: 'low', color: 'yellow', radius: 200 }
                ];

                for (let i = 0; i < 25; i++) {
                    const latOffset = (Math.random() - 0.5) * 0.1;
                    const lngOffset = (Math.random() - 0.5) * 0.1;
                    const risk = riskLevels[Math.floor(Math.random() * riskLevels.length)];

                    addZone(
                        this.startLat + latOffset,
                        this.startLng + lngOffset,
                        risk.radius,
                        risk.level,
                        risk.color,
                        `${risk.level.toUpperCase()} Risk Area`
                    );
                }
            }

            initThreeScene() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('three-canvas'),
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);

//                 // Create character
// this.character = new THREE.Mesh(
//     new THREE.CylinderGeometry(0.3, 0.4, 1.2, 16),
//     new THREE.MeshPhongMaterial({ color: 0xFF69B4 })
// );
// this.character.position.y = 0.6;
// this.scene.add(this.character);



// Create humanoid character (sculptoid)
this.character = new THREE.Group();

// Head
const head = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshPhongMaterial({ color: 0xffd700 }));
head.position.y = 2.2;
this.character.add(head);

// Hair - use spheres for a simple hair effect
const hairColor = 0x3b2a2a; // Dark brown color for hair

// Top Hair (Hair volume on top of the head)
const topHair = new THREE.Mesh(new THREE.SphereGeometry(0.45, 16, 16), new THREE.MeshPhongMaterial({ color: hairColor }));
topHair.position.y = 2.6;
this.character.add(topHair);

// Hair Sides (Side volumes of the hair)
const leftSideHair = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshPhongMaterial({ color: hairColor }));
leftSideHair.position.set(-0.35, 2.3, 0);
this.character.add(leftSideHair);

const rightSideHair = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshPhongMaterial({ color: hairColor }));
rightSideHair.position.set(0.35, 2.3, 0);
this.character.add(rightSideHair);

// Hair Back (Small volume to represent back hair)
const backHair = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshPhongMaterial({ color: hairColor }));
backHair.position.set(0, 2.0, 0.4);
this.character.add(backHair);


// Body
const body = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.8, 1.4, 16), new THREE.MeshPhongMaterial({ color: 0x007acc }));
body.position.y = 1.2;
this.character.add(body);

// // Arms
// const armMaterial = new THREE.MeshPhongMaterial({ color: 0xff6347 });
// const leftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 1, 16), armMaterial);
// leftArm.position.set(-0.9, 1.6, 0);
// leftArm.rotation.z = Math.PI / 4;

// const rightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 1, 16), armMaterial);
// rightArm.position.set(0.9, 1.6, 0);
// rightArm.rotation.z = -Math.PI / 4;

// this.character.add(leftArm);
// this.character.add(rightArm);

// Legs
const legMaterial = new THREE.MeshPhongMaterial({ color: 0xffd700 });
const leftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1.2, 16), legMaterial);
leftLeg.position.set(-0.4, 0, 0);

const rightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1.2, 16), legMaterial);
rightLeg.position.set(0.4, 0, 0);

this.character.add(leftLeg);
this.character.add(rightLeg);

// Adjust character position
this.character.position.y = 0.6;
this.scene.add(this.character);


                // Add lights
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(10, 10, 10);
                this.scene.add(dirLight);

                // Camera position
                this.camera.position.set(0, 5, 10);
                this.camera.lookAt(this.character.position);

                window.addEventListener('resize', () => this.onWindowResize());
                this.animate();
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            setupControls() {
                document.addEventListener('keydown', (e) => {
                    const moveSpeed = 0.001;

                    switch (e.key.toLowerCase()) {
                        case 'w': case 'arrowup':
                            this.startLat += moveSpeed;
                            break;
                        case 's': case 'arrowdown':
                            this.startLat -= moveSpeed;
                            break;
                        case 'a': case 'arrowleft':
                            this.startLng -= moveSpeed;
                            break;
                        case 'd': case 'arrowright':
                            this.startLng += moveSpeed;
                            break;
                    }

                    this.updatePosition();
                });
            }

            updatePosition() {
                this.map.setView([this.startLat, this.startLng], 13);
                this.checkZoneSafety();
            }

            checkZoneSafety() {
                const statusOverlay = document.getElementById('status-overlay');
                let inZone = false;

                for (const zone of this.dangerZones) {
                    const distance = this.map.distance(
                        [this.startLat, this.startLng],
                        [zone.lat, zone.lng]
                    );
                    if (distance < zone.radius) {
                        statusOverlay.textContent = `${zone.level.toUpperCase()} RISK ZONE`;
                        statusOverlay.style.backgroundColor = zone.color;
                        inZone = true;
                        break;
                    }
                }

                if (!inZone) {
                    statusOverlay.textContent = 'SAFE ZONE';
                    statusOverlay.style.backgroundColor = 'green';
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.renderer.render(this.scene, this.camera);
            }
        }

        window.onload = () => new SafetyNavigationGame();
    </script>
</body>
</html>
